<details>
  
  <summary>8주차 미션</summary>

  <details>
    <summary>8주차 정리</summary>

## 연관 관계
- 객체 지향 프로그래밍 : 하나의 객체가 다른 객체를 참조하여 연관됨
- 관계형 데이터베이스 : 하나의 테이블이 다른 테이블의 외래키 값으로 연관됨

**서로 관계 표현 방식이 달라 자연스러운 매핑 필요 -> ORM 기술 사용**

### 연관 관계 정의 규칙
- 방향 : 단방향 연관 관계, 양방향 연관 관계
- 연관 관계 주인 : 양방향 연과 관계 시, 연관 관계에서의 관리 주체
- 다중성 (Multiplicity) :  다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)

### 방향
- 관계형 데이터베이스 : 외래키로 양쪽 테이블 조인 가능 -> '방향'이라는 개념이 없음
- 객체 지향 프로그래밍 : 참조용 필드가 있는 쪽으로만 참조 가능 -> 단방향/양방향 연관 관계로 나뉨

## 단방향 연관 관계
- 참조용 필드를 한 쪽만 가지고 있는 구조
- Member → Team 접근 가능
- Team → Menber 접근 불가능 (역참조 불가)

![image](https://github.com/user-attachments/assets/6916d081-ea88-40e0-9adf-201aca15bd75)


## 양방향 연관 관계
- 참조용 필드를 양 쪽 모두 가지고 있는 구조
- Member → Team, Team → Member 접근 가능
- 연관 관계 주인을 지정해야 함

![image](https://github.com/user-attachments/assets/077f3782-83d5-4e6f-b467-3d4b85e909f5)

### 연관 관계 주인
엔티티를 양방향 연관 관계로 설정하면 객체의 참조는 두개지만 외래키는 하나가 됨

-> **테이블의 외래키를 관리할 연관 관계의 주인을 지정해야 함**

### 주인
- 외래키 관리 가능 (등록, 수정, 삭제)
- mappedBy를 사용하지 않음
- 테이블에 외래키가 있는 곳이 주인이 됨 
- 1:N, N:1 관계에선 N쪽이 외래키를 가짐

### 주인이 야닌 쪽
- 읽기만 가능(외래키 값 변경 불가능)
- mappedBy 속성 사용

## 다중성
### 다대일(N:1)
- 여러 개가 하나를 참조
- @ManyToOne
예) 여러 멤버가 하나의 팀에 소속되어 있음

### 일대다(1:N)
- 하나가 여러 개를 참조
- @OneToMany
예) 하나의 팀에 여러 멤버가 있음

### 일대일(1:1)
- 하나가 다른 하나와만 연결
- @OneToOne
예) 한 사람당 하나의 여권, 하나의 여권은 한 명에게만 속함

### 다대다(N:M)
- 여러 개가 여러 개를 참조, @ManyToMany
예) 한 게시글엔 여러 태그 등록 가능, 하나의 태그에는 여러 게시글이 포함됨
- 객체지향프로그래밍에선 다대다 관계 표현 가능
- 관계형 데이터베이스는 2개의 테이블로 다대다 관계 표현 불가능
→ **중간 테이블을 만들어 일대다 - 다대일 관계로 풀어내야 함!**

![image](https://github.com/user-attachments/assets/f17ef2e6-999f-45ea-909a-672f871b439b)

## Fetch Type
- JPA에서 엔티티를 조회할 때 **연관된 엔티티 조회 방법을 결정하는 전략**
- **연관된 엔티티를 함께 조회할 것인지 필요에 따라 조회할 것인지 결정**
- **즉시 로딩(Eager Loading)** 전략과 **지연 로딩(Lazy Loading)** 존재

## 즉시 로딩 vs 지연 로딩
### 즉시 로딩(Eager)
- **엔티티 조회 시 연관된 엔티티도 즉시 함께 조회**
- 쿼리가 복잡해지고 성능 문제가 발생할 수 있음
- 기본값

![image](https://github.com/user-attachments/assets/06c27970-8c5e-4aba-8b96-ac6e9dfd4a2b)

### 지연 로딩(LAZY)
- **관련된 엔티티가 실제로 사용될 때(필요에 따라) 조회**
- 불필요한 데이터 조회를 방지하므로 성능에 유리함

![image](https://github.com/user-attachments/assets/32f7948c-0c00-4ba7-b9d8-5acf9b70a6f4)

## Cascade
- 부모 엔티티에서 자식 엔티티에게 영속성 작업을 전이하는 설정
- 즉, **부모 엔티티가 변경될 때 연관된 자식 엔티티도 함께 처리되도록 하는 기능**
- 연관된 객체를 일일이 관리하지 않아도 되므로 코드가 간결해지고 유지보수가 쉬워짐
### Cascade Type 종류
- ALL : 모든 영속성 전이
- PERSIST : 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장
- MERGE : 부모 엔티티를 병합할 때 자식 엔티티도 함께 병합
- REMOVE : 부모 엔티티를 삭제하면 자식 엔티티도 함께 삭제
- REFRESH : 부모 엔티티를 다시 조회하면 자식 엔티티도 함께 새로고침
- DETACH : 부모 엔티티를 영속성 컨텍스트에서 분리할 때 자식 엔티티도 함께 분리

![image](https://github.com/user-attachments/assets/7af9c392-eb30-44c5-8a5e-aece22b82082)
### orpahnRemoval 이란?
- 부모 엔티티와의 연관 관계가 끊어진 자식 엔티티(고아 객체)를 DB에서 자동으로 삭제하는 옵션
- orphanRemoval을 사용하지 않는다면 고아 객체는 DB에 계속 존재함

  </details>

   <details>
    <summary>ERD 작성할 때 주의해야 할 제약조건</summary>



### 1. 기본키(Primary Key) 설정
- 모든 테이블(엔티티)은 반드시 **기본키**를 가져야 함.
- 기본키는 NULL이 불가능하며, 중복되지 않아야 함.
- 복합키 사용 시 너무 많은 칼럼을 포함하지 않도록 주의.

### 2. 외래키(Foreign Key) 제약조건
- 두 테이블 간 관계를 나타낼 때, 외래키 설정은 필수.
- 외래키는 참조 대상 테이블의 기본키 혹은 고유 키(unique key)를 참조해야 함.
- 참조 무결성 제약조건:
- ON DELETE CASCADE
- ON UPDATE RESTRICT 등 상황에 따라 적절히 설정.

### 3. NOT NULL 제약조건
- 비워서는 안 되는 필드는 NOT NULL 제약을 걸어야 함.
- 예: 사용자 이메일, 주문일자 등 필수 데이터.

### 4. Unique 제약조건
- 기본키 외에도 고유해야 하는 데이터에는 UNIQUE 제약 필요.
- 예: 사용자 이메일, 전화번호, 사용자명 등.

### 5. Default 제약조건
- 데이터 누락 시 기본값이 필요한 경우 DEFAULT 지정.
- 예: 상태값(status) → 기본값 'active'

### 6. Check 제약조건
- 특정 조건을 만족하는 값만 허용.
- 예: CHECK (age >= 0) → 나이는 음수가 될 수 없음.

### 7. 데이터 타입 정합성
- 숫자, 문자열, 날짜 등 적절한 데이터 타입 사용.
- 예: 생년월일은 DATE, 전화번호는 VARCHAR (숫자가 아닌 문자 취급).

### 8. 정규화 고려
- 제1정규형(1NF) ~ 제3정규형(3NF)까지 정규화하여 중복 최소화.
- 단, 너무 과도한 정규화는 성능 저하 우려 → 필요 시 부분 비정규화도 고려.

### 9. 관계의 카디널리티 명확히 하기
- 1:1, 1:N, N:M 관계를 명확히 설정.
- N:M 관계는 중간 테이블(조인 테이블)로 분해 필요.

### 10. 인덱스 고려
- 조회 성능을 위해 자주 검색/조인되는 컬럼에는 인덱스 고려.
- 단, 너무 많은 인덱스는 오히려 INSERT/UPDATE 시 성능 저하.



    </details>


</details>
